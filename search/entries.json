[{"text":"","title":"Untitled","url":"https://sake92.github.io/tupson/search/results.html"},{"text":"Quickstart Scastie Quickest way to start playing with Tupson is with this Scastie example. Mill             def mvnDeps = super.mvnDeps() ++ Seq(\n  mvn\"ba.sake::tupson:0.14.0\"\n)\ndef scalacOptions = super.scalacOptions() ++ Seq(\"-Yretain-trees\")\n\n          Sbt             libraryDependencies ++= Seq(\n  \"ba.sake\" %% \"tupson\" % \"0.14.0\"\n)\nscalacOptions ++= Seq(\"-Yretain-trees\")\n\n          Scala CLI             //> using dep ba.sake::tupson:0.14.0\n\n          Examples Examples are runnable with Mill:             ./mill examples.runMain write","title":"Quickstart","url":"https://sake92.github.io/tupson/tutorials/quickstart.html"},{"text":"Parsing Let's start with a simple case class MyData. The class needs to derive the JsonRW typeclass.             import ba.sake.tupson.{given, *}\n\ncase class MyData(\n    bln: Boolean,\n    int: Int,\n    s: String\n) derives JsonRW\n\n          Then, you can call parseJson[T] function on a String to parse it to the desired type:             val res = \"\"\"{ \"bln\":true, \"int\":5, \"s\":\"dsds\" }\"\"\".parseJson[MyData]\n// MyData(true,5,dsds)\n\n          General errors If parsing fails you will get a TupsonException:             \"\"\"{ \"bln\":true \"\"\".parseJson[MyData]\n// TupsonException: incomplete JSON\n\n          Specific errors Tupson will give you the most specific error(s) as possible:             \"\"\"{ \"bln\":123 }\"\"\" .parseJson[MyData]\n// Key '$.bln' with value '123' should be Boolean but it is Number; Key '$.int' is missing; Key '$.s' is missing\n\n          Collecting errors You can catch ParsingException to collect the errors. This exception contains errors: Seq[ParseError], list of errors that happened while parsing. Every ParseError object contains a JSONPath path to the field which has errors in it. You saw some of it in the error stacktrace above.             try {\n  \"\"\"{ \"bln\":123 } \"\"\" .parseJson[MyData]\n} catch {\n  case pe: ParsingException =>\n    val errors = pe.errors.mkString(\"\\\\n\")\n    println(s\"errors:\\\\n${errors}\")\n}\n// errors:\n// ParseError($.bln,should be Boolean but it is Number,Some(123))\n// ParseError($.int,is missing,None)\n// ParseError($.s,is missing,None)","title":"Parsing","url":"https://sake92.github.io/tupson/tutorials/parsing.html"},{"text":"Typesafe config Tupson integrates with the awesome Typesafe config library. You will need to add this dependency:             ba.sake::tupson-config:0.14.0 // scala-cli\n\nmvn\"ba.sake::tupson-config:0.14.0\" // mill\n\n\"ba.sake\" %% \"tupson-config\" % \"0.14.0\" // sbt\n\n\n          Real-world example in sharaf-petclinic Usage You can call .parseConfig[MyConf] function on a Config to parse it to the desired type:             import java.net.URL\nimport com.typesafe.config.ConfigFactory\nimport ba.sake.tupson.{given, *}\nimport ba.sake.tupson.config.*\n\ncase class MyConf(\n  port: Int,\n  url: URL,\n  string: String,\n  seq: Seq[String]\n) derives JsonRW\n\nval rawConfig = ConfigFactory.parseString(\"\"\"\n  port = 7777\n  url = \"http://example.com\"\n  string = \"str\"\n  seq = [a, \"b\", c]\n\"\"\")\n\nval myConf = rawConfig.parseConfig[MyConf]\n// MyConf(7777,http://example.com,str,List(a, b, c))","title":"Typesafe config","url":"https://sake92.github.io/tupson/tutorials/parsing-config.html"},{"text":"Writing Writing is really simple. Just call .toJson on your data:             import ba.sake.tupson.{given, *}\n\ncase class WriteData(\n  bln: Boolean,\n  int: Int,\n  dbl: Double,\n  str: String,\n  list: Seq[String]\n) derives JsonRW\n\nval data = WriteData(true, 5, 3.14, \"xyz\", Seq(\"a\", \"b\"))\n\ndata.toJson\n// {\"str\":\"xyz\",\"bln\":true,\"list\":[\"a\",\"b\"],\"int\":5,\"dbl\":3.14}","title":"Writing","url":"https://sake92.github.io/tupson/tutorials/writing.html"},{"text":"Maintaining backwards compatibility Let's say you have a case class MyConfig(url: String). Now you need to add another property: port: Int, but without breaking existing serialized values. You have 2 options: use an Option[Int], and set a default value later if it is missing use a Int = MyDefaultValue to avoid Option gymnastics Using Option Using Option[T] is handy when you don't have a default value. But it is a bit cumbersome to handle:             case class MyConfig(url: String, port: Option[Int]) derives JsonRW\nparsedConfig.port.getOrElse(...)\n\n          Using default value If you do have a default value for a particular property, by all means do use it. It will make your life much easier, you can pretend it was always there:             case class MyConfig(url: String, port: Int = 1234) derives JsonRW","title":"Maintaining backwards compatibility","url":"https://sake92.github.io/tupson/howtos/back-compat.html"},{"text":"Using weird key names Sometimes you need spaces or other characters in your JSON keys. You can use Scala's \"backticks\" language feature for that:             case class Address(`street no`: String) derives JsonRW\n\nval address = Address(\"My Street 123\")\n\nprintln(address.toJson)\n// {\"street no\":\"My Street 123\"}","title":"Using weird key names","url":"https://sake92.github.io/tupson/howtos/weird-key-names.html"},{"text":"Case Classes Case classes are (de)serialized as JSON objects:             import ba.sake.tupson.{given, *}\n\ncase class Address(street: String) derives JsonRW\ncase class Person(name: String, age: Int, address: Address) derives JsonRW\n\nval person = Person(\"Meho\", 33, Address(\"Sebilj\"))\n\nprintln(person.toJson)\n// { \"age\":33, \"name\":\"Meho\", \"address\": { \"street\":\"Sebilj\" } }","title":"Case Classes","url":"https://sake92.github.io/tupson/reference/case-classes.html"},{"text":"Collections Seq[T], List[T], Set[T], Array[T] are supported.             Seq.empty[String].toJson\n// []\n\nSeq(\"a\", \"b\").toJson\n// [\"a\",\"b\"]\n\n                      \"\"\" [] \"\"\".parseJson[Seq[String]]\n// Seq()\n\n\"\"\" [\"a\",\"b\"] \"\"\".parseJson[Seq[String]]\n// Seq(a,b)","title":"Collections","url":"https://sake92.github.io/tupson/reference/collections.html"},{"text":"Simple Enums Simple enums are (de)serialized as JSON strings. By \"simple\" we mean an enum that only has \"singleton cases\" as defined in the docs. That is, enum who's cases don't have a parameter clause.             enum Semaphore derives JsonRW:\n  case Red, Yellow, Green\n\nval semaphore = Semaphore.Red\nprintln(semaphore.toJson)\n// \"Red\"","title":"Simple Enums","url":"https://sake92.github.io/tupson/reference/simple-enums.html"},{"text":"Option Option[T] work (probably?) as you expect. None corresponds to JSON's null.             Option.empty[String].toJson\n// null\n\nOption(\"str\").toJson\n// \"str\"\n\n                      \"\"\" null \"\"\".parseJson[Option[String]]\n// None\n\n\"\"\" \"str\" \"\"\".parseJson[Option[String]]\n// Some(str)","title":"Option","url":"https://sake92.github.io/tupson/reference/option.html"},{"text":"Union Types In Scala 3 you can use union types in the form A | B | C. Use case: Some APIs support \"expanding objects\". E.g. they either return a String which is ID of that object, or full object T when you send a query string expand=myObject. For this you can leverage union types in natural way: someKey: String | MyObject. When parsing, Tupson will try all types (left to right) until it finds one that parses correctly. When writing, Tupson will use its runtime type to determine how to write the value.             \"1\".parseJson[Int | String | Boolean]\n// 1: Int\n\n\"\"\" \"bla\" \"\"\".parseJson[Int | String | Boolean]\n// \"bla\": String","title":"Union Types","url":"https://sake92.github.io/tupson/reference/union-types.html"},{"text":"Maps Map[String, T] work as you expect.             Map(\n    \"a\" -> 5,\n    \"b\" -> 123\n).toJson\n// {\"a\":5,\"b\":123}\n\n                      \"\"\" {\"a\":5,\"b\":123} \"\"\".parseJson[Map[String, Int]]\n// Map(a -> 5, b -> 123)\n\n          Maps are limited in the sense that the values have to be of same type. If you need them different, consider using case classes or dynamic JSON values.","title":"Maps","url":"https://sake92.github.io/tupson/reference/maps.html"},{"text":"Sum Types Here we mean sealed traits, sealed classes and non-singleton enums. Since they have one or more subtypes, we need to disambiguate between them somehow. The default discriminator Tupson uses is the @type key. Its value is the simple type name of class or enum case. This makes JSON independent of scala/java package and it is more readable. Example:             enum Color derives JsonRW:\n  case Hex(num: String)\n  case Yellow\n\nval color = Color.Hex(\"FFF\")\n\nprintln(color.toJson)\n// { \"@type\":\"Hex\", \"num\":\"FFF\" }\n\n          Custom discriminator key You can use some other key by annotating the sum type with @discriminator:\".md,             @discriminator(\"myOtherKey\")\nenum Color derives JsonRW ...\n\nprintln(color.toJson)\n// { \"myOtherKey\":\"Hex\", \"num\":\"FFF\" }","title":"Sum Types","url":"https://sake92.github.io/tupson/reference/sum-types.html"},{"text":"Dynamic JSON Sometimes you don't know exactly the structure of incoming JSON payload. Since Tupson uses Jawn's under cover, you can use its JValue directly:             import org.typelevel.jawn.ast.JValue\n\ncase class MyData(\n  str: String,\n  dynamic: JValue // this key's data can be anything: null, string, object, sequence...\n) derives JsonRW","title":"Dynamic JSON","url":"https://sake92.github.io/tupson/reference/dynamic-json.html"},{"text":"Tupson Tupson is a minimalistic Scala 3 web framework. It only does String <=> T conversions, no streaming. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: TODO","title":"Tupson","url":"https://sake92.github.io/tupson/index.html"},{"text":"Tupson Tupson is a minimalistic Scala 3 web framework. It only does String <=> T conversions, no streaming. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: TODO","title":"Tupson","url":"https://sake92.github.io/tupson/index-2.html"},{"text":"How Tos Why not implicit config Circe for example is using an implicit configuration, where you can tell it to map camelCase to snake_case etc. Tupson deliberately avoids this in order to simplify things. It is really hard to find which implicit config is being applied where, and you need to test your codecs.. meh Benefits of Tupson's simplistic approach: your code is easy for \"grep\" / Ctrl+F no mismatch between serialized version and your code your internal/domain models are separate from JSON, as they should be mapping between models is explicit","title":"How Tos","url":"https://sake92.github.io/tupson/philosophy/index.html"},{"text":"Tutorials Quickstart Writing Parsing Typesafe Config","title":"Tutorials","url":"https://sake92.github.io/tupson/tutorials/index.html"},{"text":"How Tos Here are some common questions and answers you might have when using Tupson. Weird Key Names Backwards Compatibility","title":"How Tos","url":"https://sake92.github.io/tupson/howtos/index.html"},{"text":"Reference Option Collections Maps Simple Enums Case Classes Sum Types Union Types Dynamic Json Simple types: Int, Double, Boolean, String etc work out of the box.             import ba.sake.tupson.{given, *}\n\n// write a value to JSON string\nval myValue = 123\nprintln(123.toJson) // 123\n\n// parse a value from JSON string\nval myParsedValue = ${tq}123${tq}.parseJson[Int]\nprintln(myParsedValue) // 123","title":"Reference","url":"https://sake92.github.io/tupson/reference/index.html"}]